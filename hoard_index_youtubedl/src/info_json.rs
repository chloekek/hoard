use {
    serde_json::Value,
    std::{
        fs::File,
        io::{
            self,
            BufReader,
        },
        path::Path,
    },
};

/// Data type representing the data read from
/// .info.json files generated by youtube-dl.
pub struct InfoJson
{
    pub ext: String,
    pub title: String,
    pub channel: String,
    pub description: String,
    pub webpage_url: String,
}

impl InfoJson
{
    /// Take the properties from a .info.json file
    /// and return them as an `InfoJson` value.
    pub fn from_file<P>(path: P) -> io::Result<Self>
        where P: AsRef<Path>
    {
        let file = File::open(path)?;
        let buf = BufReader::new(file);
        let mut value = serde_json::from_reader(buf)?;
        Self::from_value(&mut value)
            .map_err(|err| io::Error::new(io::ErrorKind::Other, err))
    }

    /// Like [`from_file`], but with the json string already parsed.
    ///
    /// [`from_file`]: #method.from_file
    pub fn from_value(value: &mut Value) -> Result<Self, &'static str>
    {
        macro_rules! property
        {
            ($name:ident : string) => {
                value.get_mut(stringify!($name))
                .and_then(|v| take_string(v.take()))
                .ok_or(concat!(".info.json: Missing ‘", stringify!($name), "’"))
            };
        }
        Ok(
            InfoJson{
                ext: property!(ext: string)?,
                title: property!(title: string)?,
                channel: property!(channel: string)?,
                description: property!(description: string)?,
                webpage_url: property!(webpage_url: string)?,
            },
        )
    }
}

fn take_string(value: Value) -> Option<String>
{
    match value {
        Value::String(string) => Some(string),
        _ => None,
    }
}

#[cfg(test)]
mod tests
{
    use super::*;

    #[test]
    fn test_from_file()
    {
        let path = concat!(
            "testdata/Fractals are typically not ",
            "self-similar-gB9n2gHsHN4.info.json",
        );

        let info_json = InfoJson::from_file(path).unwrap();

        assert_eq!(
            info_json.ext,
            "webm",
        );

        assert_eq!(
            info_json.title,
            "Fractals are typically not self-similar",
        );

        assert_eq!(
            info_json.channel,
            "3Blue1Brown",
        );

        assert_eq!(
            &info_json.description[0 .. 37],
            "An explanation of fractal dimension.\n",
        );

        assert_eq!(
            info_json.webpage_url,
            "https://www.youtube.com/watch?v=gB9n2gHsHN4",
        );
    }
}
